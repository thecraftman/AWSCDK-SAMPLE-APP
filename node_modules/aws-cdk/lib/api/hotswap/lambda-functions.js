"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = void 0;
const common_1 = require("./common");
/**
 * Returns `false` if the change cannot be short-circuited,
 * `true` if the change is irrelevant from a short-circuit perspective
 * (like a change to CDKMetadata),
 * or a LambdaFunctionResource if the change can be short-circuited.
 */
function isHotswappableLambdaFunctionChange(logicalId, change, assetParamsWithEnv) {
    var _a, _b;
    const lambdaCodeChange = isLambdaFunctionCodeOnlyChange(change, assetParamsWithEnv);
    if (typeof lambdaCodeChange === 'string') {
        return lambdaCodeChange;
    }
    else {
        // verify that the Asset changed - otherwise,
        // it's a Code property-only change,
        // but not to an asset change
        // (for example, going from Code.fromAsset() to Code.fromInline())
        if (!common_1.assetMetadataChanged(change)) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        let functionPhysicalName;
        try {
            functionPhysicalName = common_1.stringifyPotentialCfnExpression((_b = (_a = change.newValue) === null || _a === void 0 ? void 0 : _a.Properties) === null || _b === void 0 ? void 0 : _b.FunctionName, assetParamsWithEnv);
        }
        catch (e) {
            // It's possible we can't evaluate the function's name -
            // for example, it can use a Ref to a different resource,
            // which we wouldn't have in `assetParamsWithEnv`.
            // That's fine though - ignore any errors,
            // and treat this case the same way as if the name wasn't provided at all,
            // which means it will be looked up using the listStackResources() call
            // by the later phase (which actually does the Lambda function update)
            functionPhysicalName = undefined;
        }
        return new LambdaFunctionHotswapOperation({
            logicalId,
            physicalName: functionPhysicalName,
            code: lambdaCodeChange,
        });
    }
}
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
/**
 * Returns `true` if the change is not for a AWS::Lambda::Function,
 * but doesn't prevent short-circuiting
 * (like a change to CDKMetadata resource),
 * `false` if the change is to a AWS::Lambda::Function,
 * but not only to its Code property,
 * or a LambdaFunctionCode if the change is to a AWS::Lambda::Function,
 * and only affects its Code property.
 */
function isLambdaFunctionCodeOnlyChange(change, assetParamsWithEnv) {
    var _a;
    if (!change.newValue) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const newResourceType = change.newValue.Type;
    // Ignore Metadata changes
    if (newResourceType === 'AWS::CDK::Metadata') {
        return common_1.ChangeHotswapImpact.IRRELEVANT;
    }
    // The only other resource change we should see is a Lambda function
    if (newResourceType !== 'AWS::Lambda::Function') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    if (((_a = change.oldValue) === null || _a === void 0 ? void 0 : _a.Type) == null) {
        // this means this is a brand-new Lambda function -
        // obviously, we can't short-circuit that!
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    /*
     * On first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    let s3Bucket = '', s3Key = '';
    let foundCodeDifference = false;
    // Make sure only the code in the Lambda function changed
    const propertyUpdates = change.propertyUpdates;
    for (const updatedPropName in propertyUpdates) {
        const updatedProp = propertyUpdates[updatedPropName];
        if (updatedProp.newValue === undefined) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        for (const newPropName in updatedProp.newValue) {
            switch (newPropName) {
                case 'S3Bucket':
                    foundCodeDifference = true;
                    s3Bucket = common_1.stringifyPotentialCfnExpression(updatedProp.newValue[newPropName], assetParamsWithEnv);
                    break;
                case 'S3Key':
                    foundCodeDifference = true;
                    s3Key = common_1.stringifyPotentialCfnExpression(updatedProp.newValue[newPropName], assetParamsWithEnv);
                    break;
                default:
                    return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
            }
        }
    }
    return foundCodeDifference
        ? {
            s3Bucket,
            s3Key,
        }
        : common_1.ChangeHotswapImpact.IRRELEVANT;
}
class LambdaFunctionHotswapOperation {
    constructor(lambdaFunctionResource) {
        this.lambdaFunctionResource = lambdaFunctionResource;
    }
    async apply(sdk, stackResources) {
        var _a;
        let functionPhysicalName;
        if (this.lambdaFunctionResource.physicalName) {
            functionPhysicalName = this.lambdaFunctionResource.physicalName;
        }
        else {
            const stackResourceList = await stackResources.listStackResources();
            const foundFunctionName = (_a = stackResourceList
                .find(resSummary => resSummary.LogicalResourceId === this.lambdaFunctionResource.logicalId)) === null || _a === void 0 ? void 0 : _a.PhysicalResourceId;
            if (!foundFunctionName) {
                // if we couldn't find the function in the current stack, we can't update it
                return;
            }
            functionPhysicalName = foundFunctionName;
        }
        return sdk.lambda().updateFunctionCode({
            FunctionName: functionPhysicalName,
            S3Bucket: this.lambdaFunctionResource.code.s3Bucket,
            S3Key: this.lambdaFunctionResource.code.s3Key,
        }).promise();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEscUNBQWlLO0FBRWpLOzs7OztHQUtHO0FBQ0gsU0FBZ0Isa0NBQWtDLENBQ2hELFNBQWlCLEVBQUUsTUFBbUMsRUFBRSxrQkFBNkM7O0lBRXJHLE1BQU0sZ0JBQWdCLEdBQUcsOEJBQThCLENBQUMsTUFBTSxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDcEYsSUFBSSxPQUFPLGdCQUFnQixLQUFLLFFBQVEsRUFBRTtRQUN4QyxPQUFPLGdCQUFnQixDQUFDO0tBQ3pCO1NBQU07UUFDTCw2Q0FBNkM7UUFDN0Msb0NBQW9DO1FBQ3BDLDZCQUE2QjtRQUM3QixrRUFBa0U7UUFDbEUsSUFBSSxDQUFDLDZCQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7UUFFRCxJQUFJLG9CQUF3QyxDQUFDO1FBQzdDLElBQUk7WUFDRixvQkFBb0IsR0FBRyx3Q0FBK0IsYUFBQyxNQUFNLENBQUMsUUFBUSwwQ0FBRSxVQUFVLDBDQUFFLFlBQVksRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1NBQ3ZIO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVix3REFBd0Q7WUFDeEQseURBQXlEO1lBQ3pELGtEQUFrRDtZQUNsRCwwQ0FBMEM7WUFDMUMsMEVBQTBFO1lBQzFFLHVFQUF1RTtZQUN2RSxzRUFBc0U7WUFDdEUsb0JBQW9CLEdBQUcsU0FBUyxDQUFDO1NBQ2xDO1FBRUQsT0FBTyxJQUFJLDhCQUE4QixDQUFDO1lBQ3hDLFNBQVM7WUFDVCxZQUFZLEVBQUUsb0JBQW9CO1lBQ2xDLElBQUksRUFBRSxnQkFBZ0I7U0FDdkIsQ0FBQyxDQUFDO0tBQ0o7QUFDSCxDQUFDO0FBbkNELGdGQW1DQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsU0FBUyw4QkFBOEIs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U0FDMUM7UUFFRCxPQUFPLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQztZQUNyQyxZQUFZLEVBQUUsb0JBQW9CO1lBQ2xDLFFBQVEsRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLFFBQVE7WUFDbkQsS0FBSyxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsS0FBSztTQUM5QyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDZixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBhc3NldE1ldGFkYXRhQ2hhbmdlZCwgQ2hhbmdlSG90c3dhcEltcGFjdCwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgSG90c3dhcE9wZXJhdGlvbiwgTGlzdFN0YWNrUmVzb3VyY2VzLCBzdHJpbmdpZnlQb3RlbnRpYWxDZm5FeHByZXNzaW9uIH0gZnJvbSAnLi9jb21tb24nO1xuXG4vKipcbiAqIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgY2hhbmdlIGNhbm5vdCBiZSBzaG9ydC1jaXJjdWl0ZWQsXG4gKiBgdHJ1ZWAgaWYgdGhlIGNoYW5nZSBpcyBpcnJlbGV2YW50IGZyb20gYSBzaG9ydC1jaXJjdWl0IHBlcnNwZWN0aXZlXG4gKiAobGlrZSBhIGNoYW5nZSB0byBDREtNZXRhZGF0YSksXG4gKiBvciBhIExhbWJkYUZ1bmN0aW9uUmVzb3VyY2UgaWYgdGhlIGNoYW5nZSBjYW4gYmUgc2hvcnQtY2lyY3VpdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLCBhc3NldFBhcmFtc1dpdGhFbnY6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4pOiBDaGFuZ2VIb3Rzd2FwUmVzdWx0IHtcbiAgY29uc3QgbGFtYmRhQ29kZUNoYW5nZSA9IGlzTGFtYmRhRnVuY3Rpb25Db2RlT25seUNoYW5nZShjaGFuZ2UsIGFzc2V0UGFyYW1zV2l0aEVudik7XG4gIGlmICh0eXBlb2YgbGFtYmRhQ29kZUNoYW5nZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbGFtYmRhQ29kZUNoYW5nZTtcbiAgfSBlbHNlIHtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgQXNzZXQgY2hhbmdlZCAtIG90aGVyd2lzZSxcbiAgICAvLyBpdCdzIGEgQ29kZSBwcm9wZXJ0eS1vbmx5IGNoYW5nZSxcbiAgICAvLyBidXQgbm90IHRvIGFuIGFzc2V0IGNoYW5nZVxuICAgIC8vIChmb3IgZXhhbXBsZSwgZ29pbmcgZnJvbSBDb2RlLmZyb21Bc3NldCgpIHRvIENvZGUuZnJvbUlubGluZSgpKVxuICAgIGlmICghYXNzZXRNZXRhZGF0YUNoYW5nZWQoY2hhbmdlKSkge1xuICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgIH1cblxuICAgIGxldCBmdW5jdGlvblBoeXNpY2FsTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBmdW5jdGlvblBoeXNpY2FsTmFtZSA9IHN0cmluZ2lmeVBvdGVudGlhbENmbkV4cHJlc3Npb24oY2hhbmdlLm5ld1ZhbHVlPy5Qcm9wZXJ0aWVzPy5GdW5jdGlvbk5hbWUsIGFzc2V0UGFyYW1zV2l0aEVudik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSXQncyBwb3NzaWJsZSB3ZSBjYW4ndCBldmFsdWF0ZSB0aGUgZnVuY3Rpb24ncyBuYW1lIC1cbiAgICAgIC8vIGZvciBleGFtcGxlLCBpdCBjYW4gdXNlIGEgUmVmIHRvIGEgZGlmZmVyZW50IHJlc291cmNlLFxuICAgICAgLy8gd2hpY2ggd2Ugd291bGRuJ3QgaGF2ZSBpbiBgYXNzZXRQYXJhbXNXaXRoRW52YC5cbiAgICAgIC8vIFRoYXQncyBmaW5lIHRob3VnaCAtIGlnbm9yZSBhbnkgZXJyb3JzLFxuICAgICAgLy8gYW5kIHRyZWF0IHRoaXMgY2FzZSB0aGUgc2FtZSB3YXkgYXMgaWYgdGhlIG5hbWUgd2Fzbid0IHByb3ZpZGVkIGF0IGFsbCxcbiAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IHdpbGwgYmUgbG9va2VkIHVwIHVzaW5nIHRoZSBsaXN0U3RhY2tSZXNvdXJjZXMoKSBjYWxsXG4gICAgICAvLyBieSB0aGUgbGF0ZXIgcGhhc2UgKHdoaWNoIGFjdHVhbGx5IGRvZXMgdGhlIExhbWJkYSBmdW5jdGlvbiB1cGRhdGUpXG4gICAgICBmdW5jdGlvblBoeXNpY2FsTmFtZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExhbWJkYUZ1bmN0aW9uSG90c3dhcE9wZXJhdGlvbih7XG4gICAgICBsb2dpY2FsSWQsXG4gICAgICBwaHlzaWNhbE5hbWU6IGZ1bmN0aW9uUGh5c2ljYWxOYW1lLFxuICAgICAgY29kZTogbGFtYmRhQ29kZUNoYW5nZSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjaGFuZ2UgaXMgbm90IGZvciBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGJ1dCBkb2Vzbid0IHByZXZlbnQgc2hvcnQtY2lyY3VpdGluZ1xuICogKGxpa2UgYSBjaGFuZ2UgdG8gQ0RLTWV0YWRhdGEgcmVzb3VyY2UpLFxuICogYGZhbHNlYCBpZiB0aGUgY2hhbmdlIGlzIHRvIGEgQVdTOjpMYW1iZGE6OkZ1bmN0aW9uLFxuICogYnV0IG5vdCBvbmx5IHRvIGl0cyBDb2RlIHByb3BlcnR5LFxuICogb3IgYSBMYW1iZGFGdW5jdGlvbkNvZGUgaWYgdGhlIGNoYW5nZSBpcyB0byBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGFuZCBvbmx5IGFmZmVjdHMgaXRzIENvZGUgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGlzTGFtYmRhRnVuY3Rpb25Db2RlT25seUNoYW5nZShcbiAgY2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsIGFzc2V0UGFyYW1zV2l0aEVudjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbik6IExhbWJkYUZ1bmN0aW9uQ29kZSB8IENoYW5nZUhvdHN3YXBJbXBhY3Qge1xuICBpZiAoIWNoYW5nZS5uZXdWYWx1ZSkge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuICBjb25zdCBuZXdSZXNvdXJjZVR5cGUgPSBjaGFuZ2UubmV3VmFsdWUuVHlwZTtcbiAgLy8gSWdub3JlIE1ldGFkYXRhIGNoYW5nZXNcbiAgaWYgKG5ld1Jlc291cmNlVHlwZSA9PT0gJ0FXUzo6Q0RLOjpNZXRhZGF0YScpIHtcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UO1xuICB9XG4gIC8vIFRoZSBvbmx5IG90aGVyIHJlc291cmNlIGNoYW5nZSB3ZSBzaG91bGQgc2VlIGlzIGEgTGFtYmRhIGZ1bmN0aW9uXG4gIGlmIChuZXdSZXNvdXJjZVR5cGUgIT09ICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG4gIGlmIChjaGFuZ2Uub2xkVmFsdWU/LlR5cGUgPT0gbnVsbCkge1xuICAgIC8vIHRoaXMgbWVhbnMgdGhpcyBpcyBhIGJyYW5kLW5ldyBMYW1iZGEgZnVuY3Rpb24gLVxuICAgIC8vIG9idmlvdXNseSwgd2UgY2FuJ3Qgc2hvcnQtY2lyY3VpdCB0aGF0IVxuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIC8qXG4gICAqIE9uIGZpcnN0IGdsYW5jZSwgd2Ugd291bGQgd2FudCB0byBpbml0aWFsaXplIHRoZXNlIHVzaW5nIHRoZSBcInByZXZpb3VzXCIgdmFsdWVzIChjaGFuZ2Uub2xkVmFsdWUpLFxuICAgKiBpbiBjYXNlIG9ubHkgb25lIG9mIHRoZW0gY2hhbmdlZCwgbGlrZSB0aGUga2V5LCBhbmQgdGhlIEJ1Y2tldCBzdGF5ZWQgdGhlIHNhbWUuXG4gICAqIEhvd2V2ZXIsIHRoYXQgYWN0dWFsbHkgZmFpbHMgZm9yIG9sZC1zdHlsZSBzeW50aGVzaXMsIHdoaWNoIHVzZXMgQ0ZOIFBhcmFtZXRlcnMhXG4gICAqIEJlY2F1c2UgdGhlIG5hbWVzIG9mIHRoZSBQYXJhbWV0ZXJzIGRlcGVuZCBvbiB0aGUgaGFzaCBvZiB0aGUgQXNzZXQsXG4gICAqIHRoZSBQYXJhbWV0ZXJzIHVzZWQgZm9yIHRoZSBcIm9sZFwiIHZhbHVlcyBubyBsb25nZXIgZXhpc3QgaW4gYGFzc2V0UGFyYW1zYCBhdCB0aGlzIHBvaW50LFxuICAgKiB3aGljaCBtZWFucyB3ZSBkb24ndCBoYXZlIHRoZSBjb3JyZWN0IHZhbHVlcyBhdmFpbGFibGUgdG8gZXZhbHVhdGUgdGhlIENGTiBleHByZXNzaW9uIHdpdGguXG4gICAqIEZvcnR1bmF0ZWx5LCB0aGUgZGlmZiB3aWxsIGFsd2F5cyBpbmNsdWRlIGJvdGggdGhlIHMzQnVja2V0IGFuZCBzM0tleSBwYXJ0cyBvZiB0aGUgTGFtYmRhJ3MgQ29kZSBwcm9wZXJ0eSxcbiAgICogZXZlbiBpZiBvbmx5IG9uZSBvZiB0aGVtIHdhcyBhY3R1YWxseSBjaGFuZ2VkLFxuICAgKiB3aGljaCBtZWFucyB3ZSBkb24ndCBuZWVkIHRoZSBcIm9sZFwiIHZhbHVlcyBhdCBhbGwsIGFuZCB3ZSBjYW4gc2FmZWx5IGluaXRpYWxpemUgdGhlc2Ugd2l0aCBqdXN0IGAnJ2AuXG4gICAqL1xuICBsZXQgczNCdWNrZXQgPSAnJywgczNLZXkgPSAnJztcbiAgbGV0IGZvdW5kQ29kZURpZmZlcmVuY2UgPSBmYWxzZTtcbiAgLy8gTWFrZSBzdXJlIG9ubHkgdGhlIGNvZGUgaW4gdGhlIExhbWJkYSBmdW5jdGlvbiBjaGFuZ2VkXG4gIGNvbnN0IHByb3BlcnR5VXBkYXRlcyA9IGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXM7XG4gIGZvciAoY29uc3QgdXBkYXRlZFByb3BOYW1lIGluIHByb3BlcnR5VXBkYXRlcykge1xuICAgIGNvbnN0IHVwZGF0ZWRQcm9wID0gcHJvcGVydHlVcGRhdGVzW3VwZGF0ZWRQcm9wTmFtZV07XG4gICAgaWYgKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuZXdQcm9wTmFtZSBpbiB1cGRhdGVkUHJvcC5uZXdWYWx1ZSkge1xuICAgICAgc3dpdGNoIChuZXdQcm9wTmFtZSkge1xuICAgICAgICBjYXNlICdTM0J1Y2tldCc6XG4gICAgICAgICAgZm91bmRDb2RlRGlmZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgczNCdWNrZXQgPSBzdHJpbmdpZnlQb3RlbnRpYWxDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSwgYXNzZXRQYXJhbXNXaXRoRW52KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUzNLZXknOlxuICAgICAgICAgIGZvdW5kQ29kZURpZmZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgIHMzS2V5ID0gc3RyaW5naWZ5UG90ZW50aWFsQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0sIGFzc2V0UGFyYW1zV2l0aEVudik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3VuZENvZGVEaWZmZXJlbmNlXG4gICAgPyB7XG4gICAgICBzM0J1Y2tldCxcbiAgICAgIHMzS2V5LFxuICAgIH1cbiAgICA6IENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVDtcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uQ29kZSB7XG4gIHJlYWRvbmx5IHMzQnVja2V0OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHMzS2V5OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvblJlc291cmNlIHtcbiAgcmVhZG9ubHkgbG9naWNhbElkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHBoeXNpY2FsTmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgY29kZTogTGFtYmRhRnVuY3Rpb25Db2RlO1xufVxuXG5jbGFzcyBMYW1iZGFGdW5jdGlvbkhvdHN3YXBPcGVyYXRpb24gaW1wbGVtZW50cyBIb3Rzd2FwT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBsYW1iZGFGdW5jdGlvblJlc291cmNlOiBMYW1iZGFGdW5jdGlvblJlc291cmNlKSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYXBwbHkoc2RrOiBJU0RLLCBzdGFja1Jlc291cmNlczogTGlzdFN0YWNrUmVzb3VyY2VzKTogUHJvbWlzZTxhbnk+IHtcbiAgICBsZXQgZnVuY3Rpb25QaHlzaWNhbE5hbWU6IHN0cmluZztcbiAgICBpZiAodGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZSkge1xuICAgICAgZnVuY3Rpb25QaHlzaWNhbE5hbWUgPSB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGFja1Jlc291cmNlTGlzdCA9IGF3YWl0IHN0YWNrUmVzb3VyY2VzLmxpc3RTdGFja1Jlc291cmNlcygpO1xuICAgICAgY29uc3QgZm91bmRGdW5jdGlvbk5hbWUgPSBzdGFja1Jlc291cmNlTGlzdFxuICAgICAgICAuZmluZChyZXNTdW1tYXJ5ID0+IHJlc1N1bW1hcnkuTG9naWNhbFJlc291cmNlSWQgPT09IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5sb2dpY2FsSWQpXG4gICAgICAgID8uUGh5c2ljYWxSZXNvdXJjZUlkO1xuICAgICAgaWYgKCFmb3VuZEZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAvLyBpZiB3ZSBjb3VsZG4ndCBmaW5kIHRoZSBmdW5jdGlvbiBpbiB0aGUgY3VycmVudCBzdGFjaywgd2UgY2FuJ3QgdXBkYXRlIGl0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uUGh5c2ljYWxOYW1lID0gZm91bmRGdW5jdGlvbk5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNkay5sYW1iZGEoKS51cGRhdGVGdW5jdGlvbkNvZGUoe1xuICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvblBoeXNpY2FsTmFtZSxcbiAgICAgIFMzQnVja2V0OiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UuY29kZS5zM0J1Y2tldCxcbiAgICAgIFMzS2V5OiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UuY29kZS5zM0tleSxcbiAgICB9KS5wcm9taXNlKCk7XG4gIH1cbn1cbiJdfQ==