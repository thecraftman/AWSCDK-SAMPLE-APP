"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assetMetadataChanged = exports.stringifyPotentialCfnExpression = exports.ChangeHotswapImpact = void 0;
const evaluate_cfn_1 = require("../util/cloudformation/evaluate-cfn");
/**
 * An enum that represents the result of detection whether a given change can be hotswapped.
 */
var ChangeHotswapImpact;
(function (ChangeHotswapImpact) {
    /**
     * This result means that the given change cannot be hotswapped,
     * and requires a full deployment.
     */
    ChangeHotswapImpact["REQUIRES_FULL_DEPLOYMENT"] = "requires-full-deployment";
    /**
     * This result means that the given change can be safely be ignored when determining
     * whether the given Stack can be hotswapped or not
     * (for example, it's a change to the CDKMetadata resource).
     */
    ChangeHotswapImpact["IRRELEVANT"] = "irrelevant";
})(ChangeHotswapImpact = exports.ChangeHotswapImpact || (exports.ChangeHotswapImpact = {}));
/**
 * For old-style synthesis which uses CFN Parameters,
 * the Code properties can have the values of complex CFN expressions.
 * For new-style synthesis of env-agnostic stacks,
 * the Fn::Sub expression is used for the Asset bucket.
 * Evaluate the CFN expressions to concrete string values which we need for the
 * updateFunctionCode() service call.
 */
function stringifyPotentialCfnExpression(value, assetParamsWithEnv) {
    // if we already have a string, nothing to do
    if (value == null || typeof value === 'string') {
        return value;
    }
    // otherwise, we assume this is a CloudFormation expression that we need to evaluate
    return evaluate_cfn_1.evaluateCfn(value, assetParamsWithEnv);
}
exports.stringifyPotentialCfnExpression = stringifyPotentialCfnExpression;
function assetMetadataChanged(change) {
    var _a;
    return !!((_a = change.newValue) === null || _a === void 0 ? void 0 : _a.Metadata['aws:asset:path']);
}
exports.assetMetadataChanged = assetMetadataChanged;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdBLHNFQUFrRTtBQWFsRTs7R0FFRztBQUNILElBQVksbUJBYVg7QUFiRCxXQUFZLG1CQUFtQjtJQUM3Qjs7O09BR0c7SUFDSCw0RUFBcUQsQ0FBQTtJQUVyRDs7OztPQUlHO0lBQ0gsZ0RBQXlCLENBQUE7QUFDM0IsQ0FBQyxFQWJXLG1CQUFtQixHQUFuQiwyQkFBbUIsS0FBbkIsMkJBQW1CLFFBYTlCO0FBSUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLCtCQUErQixDQUFDLEtBQVUsRUFBRSxrQkFBNkM7SUFDdkcsNkNBQTZDO0lBQzdDLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDOUMsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELG9GQUFvRjtJQUNwRixPQUFPLDBCQUFXLENBQUMsS0FBSyxFQUFFLGtCQUFrQixDQUFDLENBQUM7QUFDaEQsQ0FBQztBQVJELDBFQVFDO0FBRUQsU0FBZ0Isb0JBQW9CLENBQUMsTUFBbUM7O0lBQ3RFLE9BQU8sQ0FBQyxRQUFDLE1BQU0sQ0FBQyxRQUFRLDBDQUFFLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBQyxDQUFDO0FBQ3ZELENBQUM7QUFGRCxvREFFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNmbl9kaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb24gfSBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBldmFsdWF0ZUNmbiB9IGZyb20gJy4uL3V0aWwvY2xvdWRmb3JtYXRpb24vZXZhbHVhdGUtY2ZuJztcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0U3RhY2tSZXNvdXJjZXMge1xuICBsaXN0U3RhY2tSZXNvdXJjZXMoKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeVtdPjtcbn1cblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIGEgY2hhbmdlIHRoYXQgY2FuIGJlIGRlcGxveWVkIGluIGEgc2hvcnQtY2lyY3VpdCBtYW5uZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSG90c3dhcE9wZXJhdGlvbiB7XG4gIGFwcGx5KHNkazogSVNESywgc3RhY2tSZXNvdXJjZXM6IExpc3RTdGFja1Jlc291cmNlcyk6IFByb21pc2U8YW55Pjtcbn1cblxuLyoqXG4gKiBBbiBlbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIGRldGVjdGlvbiB3aGV0aGVyIGEgZ2l2ZW4gY2hhbmdlIGNhbiBiZSBob3Rzd2FwcGVkLlxuICovXG5leHBvcnQgZW51bSBDaGFuZ2VIb3Rzd2FwSW1wYWN0IHtcbiAgLyoqXG4gICAqIFRoaXMgcmVzdWx0IG1lYW5zIHRoYXQgdGhlIGdpdmVuIGNoYW5nZSBjYW5ub3QgYmUgaG90c3dhcHBlZCxcbiAgICogYW5kIHJlcXVpcmVzIGEgZnVsbCBkZXBsb3ltZW50LlxuICAgKi9cbiAgUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UID0gJ3JlcXVpcmVzLWZ1bGwtZGVwbG95bWVudCcsXG5cbiAgLyoqXG4gICAqIFRoaXMgcmVzdWx0IG1lYW5zIHRoYXQgdGhlIGdpdmVuIGNoYW5nZSBjYW4gYmUgc2FmZWx5IGJlIGlnbm9yZWQgd2hlbiBkZXRlcm1pbmluZ1xuICAgKiB3aGV0aGVyIHRoZSBnaXZlbiBTdGFjayBjYW4gYmUgaG90c3dhcHBlZCBvciBub3RcbiAgICogKGZvciBleGFtcGxlLCBpdCdzIGEgY2hhbmdlIHRvIHRoZSBDREtNZXRhZGF0YSByZXNvdXJjZSkuXG4gICAqL1xuICBJUlJFTEVWQU5UID0gJ2lycmVsZXZhbnQnLFxufVxuXG5leHBvcnQgdHlwZSBDaGFuZ2VIb3Rzd2FwUmVzdWx0ID0gSG90c3dhcE9wZXJhdGlvbiB8IENoYW5nZUhvdHN3YXBJbXBhY3Q7XG5cbi8qKlxuICogRm9yIG9sZC1zdHlsZSBzeW50aGVzaXMgd2hpY2ggdXNlcyBDRk4gUGFyYW1ldGVycyxcbiAqIHRoZSBDb2RlIHByb3BlcnRpZXMgY2FuIGhhdmUgdGhlIHZhbHVlcyBvZiBjb21wbGV4IENGTiBleHByZXNzaW9ucy5cbiAqIEZvciBuZXctc3R5bGUgc3ludGhlc2lzIG9mIGVudi1hZ25vc3RpYyBzdGFja3MsXG4gKiB0aGUgRm46OlN1YiBleHByZXNzaW9uIGlzIHVzZWQgZm9yIHRoZSBBc3NldCBidWNrZXQuXG4gKiBFdmFsdWF0ZSB0aGUgQ0ZOIGV4cHJlc3Npb25zIHRvIGNvbmNyZXRlIHN0cmluZyB2YWx1ZXMgd2hpY2ggd2UgbmVlZCBmb3IgdGhlXG4gKiB1cGRhdGVGdW5jdGlvbkNvZGUoKSBzZXJ2aWNlIGNhbGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlQb3RlbnRpYWxDZm5FeHByZXNzaW9uKHZhbHVlOiBhbnksIGFzc2V0UGFyYW1zV2l0aEVudjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSk6IHN0cmluZyB7XG4gIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0cmluZywgbm90aGluZyB0byBkb1xuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlLCB3ZSBhc3N1bWUgdGhpcyBpcyBhIENsb3VkRm9ybWF0aW9uIGV4cHJlc3Npb24gdGhhdCB3ZSBuZWVkIHRvIGV2YWx1YXRlXG4gIHJldHVybiBldmFsdWF0ZUNmbih2YWx1ZSwgYXNzZXRQYXJhbXNXaXRoRW52KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2V0TWV0YWRhdGFDaGFuZ2VkKGNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIWNoYW5nZS5uZXdWYWx1ZT8uTWV0YWRhdGFbJ2F3czphc3NldDpwYXRoJ107XG59XG4iXX0=